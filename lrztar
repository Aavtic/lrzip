#!/bin/bash

# A basic skeleton for making a new lrzip tar wrapper place messages etc
# where you think you want them, it kind of self - documents itself.
# For the time being, lrzip does not like pipes.

# Public domain with no warranties or suitability whatsoever etc.
# G.M.

function lrztar_local() {
    local p="${@:1:$(($#-1))}" s="${!#}" tname= fname= \
        v_w=0 v_O=0 v_S=0 v_D=0 v_P=0 v_q=0 v_L=0 \
        v_n=0 v_l=0 v_b=0 v_g=0 v_z=0 v_M=0 v_T=0 \
        v_N=0 v_v=0 v_f=0 v_d=0 v_h=0 x=
    OPTERR=0
    trap '[[ -z $tname ]] || rm -rf "$tname" &> /dev/null' 1 2 3 15
    which tar   &> /dev/null || { printf "lrztar: no tar in your path\n"; return 1; }
    which lrzip &> /dev/null || { printf "lrztar: no lrzip in your path\n"; return 1; }
    while getopts w:O:S:DPqL:nlbgzMT:N:vfodtVh x; do
    [[ $x == [otV] ]] || ((v_$x=1)) &> /dev/null \
        || { printf "lrztar: invalid option for lrztar %s\n" "$x"; return 1; }
    done
    { ! (($#)) || ((v_h)); } && {
        printf "lrztar wrapper for compressing/decompressing while directories with lrzip.\n"
        printf "usage: lrztar [lrzip options] <directory>  will compress directory to directory.tar.lrz\n"
        printf "lrztar -d [lrzip options] <directory.tar.lrz>  will extract directory from directory.tar.lrz\n"
        printf "lrzip -h will list lrzip options\n"
        return
    }
    ((v_d)) && {
        fname="$(basename "$s")"; tname="${fname%.lrz}"
        ! ((v_f)) && [[ -e ${tname%.tar} ]] && {
            printf "lrztar: ${tname%.tar} already present, aborting\n"
            return 1
        }
        lrzip $p "$fname" && tar xf "$tname"
        x=$?
    } || {
        tname="$(basename "$s").tar"
        tar cf "$tname" "$s" && lrzip $p "$tname"
        x=$?
    }
    rm -rf "$tname" &> /dev/null
    ! ((x)) && ((v_D)) && rm -rf "$s" &> /dev/null
    return $x
}

lrztar_local "${@}"
